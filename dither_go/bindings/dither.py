
# python wrapper for package github.com/tfuxu/dither-gopy within overall package dither_go
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -no-make -output=dither_go/bindings -vm=python3 ./dither_go github.com/tfuxu/dither-gopy

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _dither_go
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from dither_go import dither
# and then refer to everything using dither. prefix
# packages imported by this package listed below:

from . import dither_go



# ---- Types ---

# Python type for slice [][]uint
class Slice_Slice_uint(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dither_go.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dither_go.IncRef(self.handle)
		else:
			self.handle = _dither_go.Slice_Slice_uint_CTor()
			_dither_go.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_uint.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dither_go.DecRef(self.handle)
	def __str__(self):
		s = 'dither.Slice_Slice_uint len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dither.Slice_Slice_uint([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dither_go.Slice_Slice_uint_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dither_go.Slice_Slice_uint_len(self.handle)
				return Slice_Slice_uint(handle=_dither_go.Slice_Slice_uint_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Slice_uint(handle=_dither_go.Slice_Slice_uint_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dither_go.Slice_Slice_uint_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_uint.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _dither_go.Slice_Slice_uint_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dither_go.Slice_Slice_uint_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---
def Atkinson():
	"""
	Atkinson Gets Go Variable: dither.Atkinson
	
	"""
	return ErrorDiffusionMatrix(handle=_dither_go.dither_Atkinson())

def Set_Atkinson(value):
	"""
	Set_Atkinson Sets Go Variable: dither.Atkinson
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_Atkinson(value.handle)
	else:
		_dither_go.dither_Set_Atkinson(value)

def Burkes():
	"""
	Burkes Gets Go Variable: dither.Burkes
	
	"""
	return ErrorDiffusionMatrix(handle=_dither_go.dither_Burkes())

def Set_Burkes(value):
	"""
	Set_Burkes Sets Go Variable: dither.Burkes
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_Burkes(value.handle)
	else:
		_dither_go.dither_Set_Burkes(value)

def ClusteredDot4x4():
	"""
	ClusteredDot4x4 Gets Go Variable: dither.ClusteredDot4x4
	ClusteredDot4x4 comes from http://caca.zoy.org/study/part2.html
	
	It is not diagonal, so the dots form a grid.
	
	"""
	return OrderedDitherMatrix(handle=_dither_go.dither_ClusteredDot4x4())

def Set_ClusteredDot4x4(value):
	"""
	Set_ClusteredDot4x4 Sets Go Variable: dither.ClusteredDot4x4
	ClusteredDot4x4 comes from http://caca.zoy.org/study/part2.html
	
	It is not diagonal, so the dots form a grid.
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_ClusteredDot4x4(value.handle)
	else:
		_dither_go.dither_Set_ClusteredDot4x4(value)

def ClusteredDot6x6():
	"""
	ClusteredDot6x6 Gets Go Variable: dither.ClusteredDot6x6
	ClusteredDot6x6 comes from Figure 5.9 of the book Digital Halftoning by
	Robert Ulichney. It can represent "37 levels of gray". It is not diagonal.
	
	"""
	return OrderedDitherMatrix(handle=_dither_go.dither_ClusteredDot6x6())

def Set_ClusteredDot6x6(value):
	"""
	Set_ClusteredDot6x6 Sets Go Variable: dither.ClusteredDot6x6
	ClusteredDot6x6 comes from Figure 5.9 of the book Digital Halftoning by
	Robert Ulichney. It can represent "37 levels of gray". It is not diagonal.
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_ClusteredDot6x6(value.handle)
	else:
		_dither_go.dither_Set_ClusteredDot6x6(value)

def ClusteredDot6x6_2():
	"""
	ClusteredDot6x6_2 Gets Go Variable: dither.ClusteredDot6x6_2
	ClusteredDot6x6_2 comes from https://archive.is/71e9G. On the webpage it is
	called "central white point" while ClusteredDot6x6 is called "clustered dots".
	
	It is nearly identical to ClusteredDot6x6.
	
	"""
	return OrderedDitherMatrix(handle=_dither_go.dither_ClusteredDot6x6_2())

def Set_ClusteredDot6x6_2(value):
	"""
	Set_ClusteredDot6x6_2 Sets Go Variable: dither.ClusteredDot6x6_2
	ClusteredDot6x6_2 comes from https://archive.is/71e9G. On the webpage it is
	called "central white point" while ClusteredDot6x6 is called "clustered dots".
	
	It is nearly identical to ClusteredDot6x6.
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_ClusteredDot6x6_2(value.handle)
	else:
		_dither_go.dither_Set_ClusteredDot6x6_2(value)

def ClusteredDot6x6_3():
	"""
	ClusteredDot6x6_3 Gets Go Variable: dither.ClusteredDot6x6_3
	ClusteredDot6x6_3 comes from https://archive.is/71e9G. On the webpage it is
	called "balanced centered point".
	
	It is nearly identical to ClusteredDot6x6.
	
	"""
	return OrderedDitherMatrix(handle=_dither_go.dither_ClusteredDot6x6_3())

def Set_ClusteredDot6x6_3(value):
	"""
	Set_ClusteredDot6x6_3 Sets Go Variable: dither.ClusteredDot6x6_3
	ClusteredDot6x6_3 comes from https://archive.is/71e9G. On the webpage it is
	called "balanced centered point".
	
	It is nearly identical to ClusteredDot6x6.
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_ClusteredDot6x6_3(value.handle)
	else:
		_dither_go.dither_Set_ClusteredDot6x6_3(value)

def ClusteredDot8x8():
	"""
	ClusteredDot8x8 Gets Go Variable: dither.ClusteredDot8x8
	ClusteredDot8x8 comes from Figure 1.5 of the book Modern Digital Halftoning,
	Second Edition, by Daniel L. Lau and Gonzalo R. Arce. It is like
	ClusteredDotDiagonal8x8, but is not diagonal. It can represent "65 gray-levels".
	
	"""
	return OrderedDitherMatrix(handle=_dither_go.dither_ClusteredDot8x8())

def Set_ClusteredDot8x8(value):
	"""
	Set_ClusteredDot8x8 Sets Go Variable: dither.ClusteredDot8x8
	ClusteredDot8x8 comes from Figure 1.5 of the book Modern Digital Halftoning,
	Second Edition, by Daniel L. Lau and Gonzalo R. Arce. It is like
	ClusteredDotDiagonal8x8, but is not diagonal. It can represent "65 gray-levels".
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_ClusteredDot8x8(value.handle)
	else:
		_dither_go.dither_Set_ClusteredDot8x8(value)

def ClusteredDotDiagonal16x16():
	"""
	ClusteredDotDiagonal16x16 Gets Go Variable: dither.ClusteredDotDiagonal16x16
	ClusteredDotDiagonal16x16 comes from Figure 5.4 of the book Digital Halftoning by
	Robert Ulichney. In the book it's called "M = 8". It can represent "129 levels
	of gray". Its dimensions are 16x16, but as a diagonal matrix it is 17x17. It is
	called "Diagonal" because the resulting dot pattern is at a 45 degree angle.
	
	"""
	return OrderedDitherMatrix(handle=_dither_go.dither_ClusteredDotDiagonal16x16())

def Set_ClusteredDotDiagonal16x16(value):
	"""
	Set_ClusteredDotDiagonal16x16 Sets Go Variable: dither.ClusteredDotDiagonal16x16
	ClusteredDotDiagonal16x16 comes from Figure 5.4 of the book Digital Halftoning by
	Robert Ulichney. In the book it's called "M = 8". It can represent "129 levels
	of gray". Its dimensions are 16x16, but as a diagonal matrix it is 17x17. It is
	called "Diagonal" because the resulting dot pattern is at a 45 degree angle.
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_ClusteredDotDiagonal16x16(value.handle)
	else:
		_dither_go.dither_Set_ClusteredDotDiagonal16x16(value)

def ClusteredDotDiagonal6x6():
	"""
	ClusteredDotDiagonal6x6 Gets Go Variable: dither.ClusteredDotDiagonal6x6
	ClusteredDotDiagonal6x6 comes from Figure 5.4 of the book Digital Halftoning by
	Robert Ulichney. In the book it's called "M = 3". It can represent "19 levels
	of gray". Its dimensions are 6x6, but as a diagonal matrix it is 7x7. It is called
	"Diagonal" because the resulting dot pattern is at a 45 degree angle.
	
	"""
	return OrderedDitherMatrix(handle=_dither_go.dither_ClusteredDotDiagonal6x6())

def Set_ClusteredDotDiagonal6x6(value):
	"""
	Set_ClusteredDotDiagonal6x6 Sets Go Variable: dither.ClusteredDotDiagonal6x6
	ClusteredDotDiagonal6x6 comes from Figure 5.4 of the book Digital Halftoning by
	Robert Ulichney. In the book it's called "M = 3". It can represent "19 levels
	of gray". Its dimensions are 6x6, but as a diagonal matrix it is 7x7. It is called
	"Diagonal" because the resulting dot pattern is at a 45 degree angle.
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_ClusteredDotDiagonal6x6(value.handle)
	else:
		_dither_go.dither_Set_ClusteredDotDiagonal6x6(value)

def ClusteredDotDiagonal8x8():
	"""
	ClusteredDotDiagonal8x8 Gets Go Variable: dither.ClusteredDotDiagonal8x8
	ClusteredDotDiagonal8x8 comes from http://caca.zoy.org/study/part2.html
	
	They say it "mimics the halftoning techniques used by newspapers". It is called
	"Diagonal" because the resulting dot pattern is at a 45 degree angle.
	
	"""
	return OrderedDitherMatrix(handle=_dither_go.dither_ClusteredDotDiagonal8x8())

def Set_ClusteredDotDiagonal8x8(value):
	"""
	Set_ClusteredDotDiagonal8x8 Sets Go Variable: dither.ClusteredDotDiagonal8x8
	ClusteredDotDiagonal8x8 comes from http://caca.zoy.org/study/part2.html
	
	They say it "mimics the halftoning techniques used by newspapers". It is called
	"Diagonal" because the resulting dot pattern is at a 45 degree angle.
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_ClusteredDotDiagonal8x8(value.handle)
	else:
		_dither_go.dither_Set_ClusteredDotDiagonal8x8(value)

def ClusteredDotDiagonal8x8_2():
	"""
	ClusteredDotDiagonal8x8_2 Gets Go Variable: dither.ClusteredDotDiagonal8x8_2
	ClusteredDotDiagonal8x8_2 comes from Figure 5.4 of the book Digital Halftoning by
	Robert Ulichney. In the book it's called "M = 4". It can represent "33 levels
	of gray". Its dimensionsare 8x8, but as a diagonal matrix it is 9x9. It is called
	"Diagonal" because the resulting dot pattern is at a 45 degree angle.
	
	It is almost identical to ClusteredDotDiagonal8x8, but worse because it can
	represent fewer gray levels. There is not much point in using it.
	
	"""
	return OrderedDitherMatrix(handle=_dither_go.dither_ClusteredDotDiagonal8x8_2())

def Set_ClusteredDotDiagonal8x8_2(value):
	"""
	Set_ClusteredDotDiagonal8x8_2 Sets Go Variable: dither.ClusteredDotDiagonal8x8_2
	ClusteredDotDiagonal8x8_2 comes from Figure 5.4 of the book Digital Halftoning by
	Robert Ulichney. In the book it's called "M = 4". It can represent "33 levels
	of gray". Its dimensionsare 8x8, but as a diagonal matrix it is 9x9. It is called
	"Diagonal" because the resulting dot pattern is at a 45 degree angle.
	
	It is almost identical to ClusteredDotDiagonal8x8, but worse because it can
	represent fewer gray levels. There is not much point in using it.
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_ClusteredDotDiagonal8x8_2(value.handle)
	else:
		_dither_go.dither_Set_ClusteredDotDiagonal8x8_2(value)

def ClusteredDotDiagonal8x8_3():
	"""
	ClusteredDotDiagonal8x8_3 Gets Go Variable: dither.ClusteredDotDiagonal8x8_3
	ClusteredDotDiagonal8x8_3 comes from https://archive.is/71e9G. On the webpage
	it is called "diagonal ordered matrix with balanced centered points".
	
	It is almost identical to ClusteredDotDiagonal8x8, but worse because it can
	represent fewer gray levels. There is not much point in using it.
	
	It is called "Diagonal" because the resulting dot pattern is at a 45 degree angle.
	
	"""
	return OrderedDitherMatrix(handle=_dither_go.dither_ClusteredDotDiagonal8x8_3())

def Set_ClusteredDotDiagonal8x8_3(value):
	"""
	Set_ClusteredDotDiagonal8x8_3 Sets Go Variable: dither.ClusteredDotDiagonal8x8_3
	ClusteredDotDiagonal8x8_3 comes from https://archive.is/71e9G. On the webpage
	it is called "diagonal ordered matrix with balanced centered points".
	
	It is almost identical to ClusteredDotDiagonal8x8, but worse because it can
	represent fewer gray levels. There is not much point in using it.
	
	It is called "Diagonal" because the resulting dot pattern is at a 45 degree angle.
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_ClusteredDotDiagonal8x8_3(value.handle)
	else:
		_dither_go.dither_Set_ClusteredDotDiagonal8x8_3(value)

def ClusteredDotHorizontalLine():
	"""
	ClusteredDotHorizontalLine Gets Go Variable: dither.ClusteredDotHorizontalLine
	ClusteredDotHorizontalLine comes from Figure 5.13 of the book Digital Halftoning by
	Robert Ulichney. It can represent "37 levels of gray". Its dimensions are 6x6.
	
	It "clusters pixels about horizontal lines".
	
	"""
	return OrderedDitherMatrix(handle=_dither_go.dither_ClusteredDotHorizontalLine())

def Set_ClusteredDotHorizontalLine(value):
	"""
	Set_ClusteredDotHorizontalLine Sets Go Variable: dither.ClusteredDotHorizontalLine
	ClusteredDotHorizontalLine comes from Figure 5.13 of the book Digital Halftoning by
	Robert Ulichney. It can represent "37 levels of gray". Its dimensions are 6x6.
	
	It "clusters pixels about horizontal lines".
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_ClusteredDotHorizontalLine(value.handle)
	else:
		_dither_go.dither_Set_ClusteredDotHorizontalLine(value)

def ClusteredDotSpiral5x5():
	"""
	ClusteredDotSpiral5x5 Gets Go Variable: dither.ClusteredDotSpiral5x5
	ClusteredDotSpiral5x5 comes from Figure 5.13 of the book Digital Halftoning by
	Robert Ulichney. It can represent "26 levels of gray". Its dimensions are 5x5.
	
	Instead of alternating dark and light dots like the other clustered-dot
	matrices, the dark parts grow to fill the area.
	
	"""
	return OrderedDitherMatrix(handle=_dither_go.dither_ClusteredDotSpiral5x5())

def Set_ClusteredDotSpiral5x5(value):
	"""
	Set_ClusteredDotSpiral5x5 Sets Go Variable: dither.ClusteredDotSpiral5x5
	ClusteredDotSpiral5x5 comes from Figure 5.13 of the book Digital Halftoning by
	Robert Ulichney. It can represent "26 levels of gray". Its dimensions are 5x5.
	
	Instead of alternating dark and light dots like the other clustered-dot
	matrices, the dark parts grow to fill the area.
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_ClusteredDotSpiral5x5(value.handle)
	else:
		_dither_go.dither_Set_ClusteredDotSpiral5x5(value)

def ClusteredDotVerticalLine():
	"""
	ClusteredDotVerticalLine Gets Go Variable: dither.ClusteredDotVerticalLine
	ClusteredDotVerticalLine is my rotated version of ClusteredDotHorizontalLine.
	
	"""
	return OrderedDitherMatrix(handle=_dither_go.dither_ClusteredDotVerticalLine())

def Set_ClusteredDotVerticalLine(value):
	"""
	Set_ClusteredDotVerticalLine Sets Go Variable: dither.ClusteredDotVerticalLine
	ClusteredDotVerticalLine is my rotated version of ClusteredDotHorizontalLine.
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_ClusteredDotVerticalLine(value.handle)
	else:
		_dither_go.dither_Set_ClusteredDotVerticalLine(value)

def FalseFloydSteinberg():
	"""
	FalseFloydSteinberg Gets Go Variable: dither.FalseFloydSteinberg
	
	"""
	return ErrorDiffusionMatrix(handle=_dither_go.dither_FalseFloydSteinberg())

def Set_FalseFloydSteinberg(value):
	"""
	Set_FalseFloydSteinberg Sets Go Variable: dither.FalseFloydSteinberg
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_FalseFloydSteinberg(value.handle)
	else:
		_dither_go.dither_Set_FalseFloydSteinberg(value)

def FloydSteinberg():
	"""
	FloydSteinberg Gets Go Variable: dither.FloydSteinberg
	
	"""
	return ErrorDiffusionMatrix(handle=_dither_go.dither_FloydSteinberg())

def Set_FloydSteinberg(value):
	"""
	Set_FloydSteinberg Sets Go Variable: dither.FloydSteinberg
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_FloydSteinberg(value.handle)
	else:
		_dither_go.dither_Set_FloydSteinberg(value)

def Horizontal3x5():
	"""
	Horizontal3x5 Gets Go Variable: dither.Horizontal3x5
	Horizontal3x5 is my rotated version of Vertical5x3.
	
	"""
	return OrderedDitherMatrix(handle=_dither_go.dither_Horizontal3x5())

def Set_Horizontal3x5(value):
	"""
	Set_Horizontal3x5 Sets Go Variable: dither.Horizontal3x5
	Horizontal3x5 is my rotated version of Vertical5x3.
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_Horizontal3x5(value.handle)
	else:
		_dither_go.dither_Set_Horizontal3x5(value)

def JarvisJudiceNinke():
	"""
	JarvisJudiceNinke Gets Go Variable: dither.JarvisJudiceNinke
	
	"""
	return ErrorDiffusionMatrix(handle=_dither_go.dither_JarvisJudiceNinke())

def Set_JarvisJudiceNinke(value):
	"""
	Set_JarvisJudiceNinke Sets Go Variable: dither.JarvisJudiceNinke
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_JarvisJudiceNinke(value.handle)
	else:
		_dither_go.dither_Set_JarvisJudiceNinke(value)

def Sierra():
	"""
	Sierra Gets Go Variable: dither.Sierra
	
	"""
	return ErrorDiffusionMatrix(handle=_dither_go.dither_Sierra())

def Set_Sierra(value):
	"""
	Set_Sierra Sets Go Variable: dither.Sierra
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_Sierra(value.handle)
	else:
		_dither_go.dither_Set_Sierra(value)

def Sierra2():
	"""
	Sierra2 Gets Go Variable: dither.Sierra2
	Sierra2 is another name for TwoRowSierra
	
	"""
	return ErrorDiffusionMatrix(handle=_dither_go.dither_Sierra2())

def Set_Sierra2(value):
	"""
	Set_Sierra2 Sets Go Variable: dither.Sierra2
	Sierra2 is another name for TwoRowSierra
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_Sierra2(value.handle)
	else:
		_dither_go.dither_Set_Sierra2(value)

def Sierra2_4A():
	"""
	Sierra2_4A Gets Go Variable: dither.Sierra2_4A
	Sierra2_4A (usually written as Sierra2-4A) is another name for SierraLite.
	
	"""
	return ErrorDiffusionMatrix(handle=_dither_go.dither_Sierra2_4A())

def Set_Sierra2_4A(value):
	"""
	Set_Sierra2_4A Sets Go Variable: dither.Sierra2_4A
	Sierra2_4A (usually written as Sierra2-4A) is another name for SierraLite.
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_Sierra2_4A(value.handle)
	else:
		_dither_go.dither_Set_Sierra2_4A(value)

def Sierra3():
	"""
	Sierra3 Gets Go Variable: dither.Sierra3
	Sierra3 is another name for the original Sierra matrix.
	
	"""
	return ErrorDiffusionMatrix(handle=_dither_go.dither_Sierra3())

def Set_Sierra3(value):
	"""
	Set_Sierra3 Sets Go Variable: dither.Sierra3
	Sierra3 is another name for the original Sierra matrix.
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_Sierra3(value.handle)
	else:
		_dither_go.dither_Set_Sierra3(value)

def SierraLite():
	"""
	SierraLite Gets Go Variable: dither.SierraLite
	
	"""
	return ErrorDiffusionMatrix(handle=_dither_go.dither_SierraLite())

def Set_SierraLite(value):
	"""
	Set_SierraLite Sets Go Variable: dither.SierraLite
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_SierraLite(value.handle)
	else:
		_dither_go.dither_Set_SierraLite(value)

def Simple2D():
	"""
	Simple2D Gets Go Variable: dither.Simple2D
	
	"""
	return ErrorDiffusionMatrix(handle=_dither_go.dither_Simple2D())

def Set_Simple2D(value):
	"""
	Set_Simple2D Sets Go Variable: dither.Simple2D
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_Simple2D(value.handle)
	else:
		_dither_go.dither_Set_Simple2D(value)

def StevenPigeon():
	"""
	StevenPigeon Gets Go Variable: dither.StevenPigeon
	StevenPigeon is an error diffusion matrix developed by Steven Pigeon.
	Source: https://hbfs.wordpress.com/2013/12/31/dithering/
	
	"""
	return ErrorDiffusionMatrix(handle=_dither_go.dither_StevenPigeon())

def Set_StevenPigeon(value):
	"""
	Set_StevenPigeon Sets Go Variable: dither.StevenPigeon
	StevenPigeon is an error diffusion matrix developed by Steven Pigeon.
	Source: https://hbfs.wordpress.com/2013/12/31/dithering/
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_StevenPigeon(value.handle)
	else:
		_dither_go.dither_Set_StevenPigeon(value)

def Stucki():
	"""
	Stucki Gets Go Variable: dither.Stucki
	
	"""
	return ErrorDiffusionMatrix(handle=_dither_go.dither_Stucki())

def Set_Stucki(value):
	"""
	Set_Stucki Sets Go Variable: dither.Stucki
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_Stucki(value.handle)
	else:
		_dither_go.dither_Set_Stucki(value)

def TwoRowSierra():
	"""
	TwoRowSierra Gets Go Variable: dither.TwoRowSierra
	
	"""
	return ErrorDiffusionMatrix(handle=_dither_go.dither_TwoRowSierra())

def Set_TwoRowSierra(value):
	"""
	Set_TwoRowSierra Sets Go Variable: dither.TwoRowSierra
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_TwoRowSierra(value.handle)
	else:
		_dither_go.dither_Set_TwoRowSierra(value)

def Vertical5x3():
	"""
	Vertical5x3 Gets Go Variable: dither.Vertical5x3
	Vertical5x3 comes from http://caca.zoy.org/study/part2.html
	
	They say it "creates artistic vertical line artifacts".
	
	"""
	return OrderedDitherMatrix(handle=_dither_go.dither_Vertical5x3())

def Set_Vertical5x3(value):
	"""
	Set_Vertical5x3 Sets Go Variable: dither.Vertical5x3
	Vertical5x3 comes from http://caca.zoy.org/study/part2.html
	
	They say it "creates artistic vertical line artifacts".
	
	"""
	if isinstance(value, go.GoClass):
		_dither_go.dither_Set_Vertical5x3(value.handle)
	else:
		_dither_go.dither_Set_Vertical5x3(value)



# ---- Interfaces ---


# ---- Structs ---

# Python type for struct dither.Ditherer
class Ditherer(go.GoClass):
	"""Ditherer dithers images according to the settings in the struct.\nIt can be safely reused for many images, and used concurrently.\n\nSome members of the struct are public. Those members can be changed\nin-between dithering images, if you would like to dither again.\nIf you change those public methods while an image is being dithered, the\noutput image will have problems, so only change in-between dithering.\n\nYou can only set one of Matrix, Mapper, or Special. Trying to dither when\nnone or more than one of those are set will cause the function to panic.\n\nAll methods can handle images with transparency, unless otherwise specified.\nRead the docs before using!\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dither_go.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dither_go.IncRef(self.handle)
		else:
			self.handle = _dither_go.dither_Ditherer_CTor()
			_dither_go.IncRef(self.handle)
			if  0 < len(args):
				self.Matrix = args[0]
			if "Matrix" in kwargs:
				self.Matrix = kwargs["Matrix"]
			if  2 < len(args):
				self.Special = args[2]
			if "Special" in kwargs:
				self.Special = kwargs["Special"]
			if  3 < len(args):
				self.SingleThreaded = args[3]
			if "SingleThreaded" in kwargs:
				self.SingleThreaded = kwargs["SingleThreaded"]
			if  4 < len(args):
				self.Serpentine = args[4]
			if "Serpentine" in kwargs:
				self.Serpentine = kwargs["Serpentine"]
	def __del__(self):
		_dither_go.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'dither.Ditherer{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'dither.Ditherer ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Matrix(self):
		"""Matrix is the ErrorDiffusionMatrix for dithering.
		"""
		return ErrorDiffusionMatrix(handle=_dither_go.dither_Ditherer_Matrix_Get(self.handle))
	@Matrix.setter
	def Matrix(self, value):
		if isinstance(value, go.GoClass):
			_dither_go.dither_Ditherer_Matrix_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Special(self):
		"""Special is the special dithering algorithm that's being used. The default
		value of 0 indicates that no special dithering algorithm is being used.
		"""
		return _dither_go.dither_Ditherer_Special_Get(self.handle)
	@Special.setter
	def Special(self, value):
		if isinstance(value, go.GoClass):
			_dither_go.dither_Ditherer_Special_Set(self.handle, value.handle)
		else:
			_dither_go.dither_Ditherer_Special_Set(self.handle, value)
	@property
	def SingleThreaded(self):
		"""SingleThreaded controls whether the dithering happens sequentially or using
		runtime.GOMAXPROCS(0) workers, which defaults to the number of CPUs.
		
		Note that error diffusion dithering (using Matrix) is sequential by nature
		and so this field has no effect.
		
		Setting this to true is only useful in rare cases, like when numbers are
		used sequentially in a PixelMapper, and the output must be deterministic.
		Because otherwise the numbers will be retrieved in a different order each
		time, as the goroutines call on the PixelMapper.
		"""
		return _dither_go.dither_Ditherer_SingleThreaded_Get(self.handle)
	@SingleThreaded.setter
	def SingleThreaded(self, value):
		if isinstance(value, go.GoClass):
			_dither_go.dither_Ditherer_SingleThreaded_Set(self.handle, value.handle)
		else:
			_dither_go.dither_Ditherer_SingleThreaded_Set(self.handle, value)
	@property
	def Serpentine(self):
		"""Serpentine controls whether the error diffusion matrix is applied in a
		serpentine manner, meaning that it goes right-to-left every other line.
		This greatly reduces line-type artifacts. If a Mapper is being used this
		field will have no effect.
		"""
		return _dither_go.dither_Ditherer_Serpentine_Get(self.handle)
	@Serpentine.setter
	def Serpentine(self, value):
		if isinstance(value, go.GoClass):
			_dither_go.dither_Ditherer_Serpentine_Set(self.handle, value.handle)
		else:
			_dither_go.dither_Ditherer_Serpentine_Set(self.handle, value)
	def SetBayer(self, x, y, strength, goRun=False):
		"""SetBayer(int x, int y, float strength) 
		
		Sets Bayer PixelMapper to Ditherer stuct.
		
		The provided dimensions of the bayer matrix [x,y] can only be powers of 2, but they do not need to be the same.
		If they are not powers of two, this function will panic.
		
		Refer to documentation for `Bayer` function to get more information:
		https://pkg.go.dev/github.com/makeworld-the-better-one/dither/v2#Bayer
		"""
		_dither_go.dither_Ditherer_SetBayer(self.handle, x, y, strength, goRun)
	def SetOrdered(self, odm, strength, goRun=False):
		"""SetOrdered(object odm, float strength) 
		
		SetOrdered sets a dither matrix as a PixelMapper to Ditherer stuct.
		Refer to documentation for `PixelMapperFromMatrix` function to get more information:
		https://pkg.go.dev/github.com/makeworld-the-better-one/dither/v2#PixelMapperFromMatrix
		"""
		_dither_go.dither_Ditherer_SetOrdered(self.handle, odm.handle, strength, goRun)
	def SetRandomGrayscale(self, min, max, goRun=False):
		"""SetRandomGrayscale(float min, float max) 
		
		SetRandomGrayscale generates a grayscale random noise dithering and sets it to Ditherer stuct.
		Refer to documentation for `RandomNoiseGrayscale` function to get more information:
		https://pkg.go.dev/github.com/makeworld-the-better-one/dither/v2#RandomNoiseGrayscale
		"""
		_dither_go.dither_Ditherer_SetRandomGrayscale(self.handle, min, max, goRun)
	def SetRandomRGB(self, minR, maxR, minG, maxG, minB, maxB, goRun=False):
		"""SetRandomRGB(float minR, float maxR, float minG, float maxG, float minB, float maxB) 
		
		SetRandomRGB generates a random noise dithering in RGB format and sets it to Ditherer stuct.
		Refer to documentation for `RandomNoiseRGB` function to get more information:
		https://pkg.go.dev/github.com/makeworld-the-better-one/dither/v2#RandomNoiseRGB
		"""
		_dither_go.dither_Ditherer_SetRandomRGB(self.handle, minR, maxR, minG, maxG, minB, maxB, goRun)
	def ClearMapper(self, goRun=False):
		"""ClearMapper() 
		
		ClearMapper clears out Mapper field of Ditherer struct.
		Useful if you want to reuse Ditherer object for the next dithering.
		"""
		_dither_go.dither_Ditherer_ClearMapper(self.handle, goRun)
	def GetPalette(self):
		"""GetPalette() []object
		
		GetPalette returns a copy of the current palette being used by the Ditherer.
		"""
		return dither_go.Slice_color_Color(handle=_dither_go.dither_Ditherer_GetPalette(self.handle))
	def Dither(self, src):
		"""Dither(object src) object
		
		Dither dithers the provided image.
		
		It will always try to change the provided image and return it, but if that
		is not possible it will return the dithered image as a copy.
		
		In comparison to DitherCopy, this can greatly reduce memory usage, and is quicker
		because it usually won't copy the image at the beginning. It should be preferred
		if you don't need to keep the original image.
		
		Cases where a copy will be are limited to:
		If the input image is *image.Paletted and the image's palette is different than
		the Ditherer's, or if the image can't be casted to draw.Image.
		
		The returned image type when copied is *image.RGBA. But it may be different if
		the image wasn't copied.
		"""
		return go.image_Image(handle=_dither_go.dither_Ditherer_Dither(self.handle, src.handle))
	def GetColorModel(self):
		"""GetColorModel() object
		
		GetColorModel returns a copy of the Ditherer's palette as a color.Model that finds the
		closest color using Euclidean distance in sRGB space.
		"""
		return go.color_Model(handle=_dither_go.dither_Ditherer_GetColorModel(self.handle))
	def DitherCopy(self, src):
		"""DitherCopy(object src) object
		
		DitherCopy dithers a copy of the src image and returns it. The src image remains
		unchanged. If you don't need to keep the original image, use Dither.
		"""
		return go.Ptr_image_RGBA(handle=_dither_go.dither_Ditherer_DitherCopy(self.handle, src.handle))
	def DitherPaletted(self, src):
		"""DitherPaletted(object src) object
		
		DitherPaletted dithers a copy of the src image and returns it as an
		*image.Paletted. The src image remains unchanged. If you don't need an
		*image.Paletted, using Dither or DitherCopy should be preferred.
		
		The palette of the returned image is the same palette the ditherer uses
		internally -- it will be equal to the output of GetPalette().
		
		If the Ditherer's palette has over 256 colors then the function will panic,
		because *image.Paletted does not allow for that.
		
		DitherPaletted can't handle images with transparency.
		"""
		return go.Ptr_image_Paletted(handle=_dither_go.dither_Ditherer_DitherPaletted(self.handle, src.handle))
	def Draw(self, dst, r, src, sp, goRun=False):
		"""Draw(object dst, object r, object src, object sp) 
		
		Draw implements draw.Drawer. This means you can use a Ditherer
		in many places, such as for encoding GIFs.
		
		Draw ignores whether dst has a palette or not, and just uses the internal Ditherer
		palette. If the dst image passed has a palette (i.e. is of the type *image.Paletted),
		and the palette is the not the same as the Ditherer's palette, it will panic.
		"""
		_dither_go.dither_Ditherer_Draw(self.handle, dst.handle, r.handle, src.handle, sp.handle, goRun)
	def Quantize(self, p, m):
		"""Quantize([]object p, object m) []object
		
		Quantize implements draw.Quantizer. It ignores the provided image
		and just returns the Ditherer's palette each time. This is useful for places that
		only allow you to set the palette through a draw.Quantizer, like the image/gif
		package.
		
		This function will panic if the Ditherer's palette has more colors than the
		caller wants, which the caller indicates by cap(p).
		
		It will also panic if there's already colors in the color.Palette provided
		to the func and not all of those colors are included in the Ditherer's palette.
		This is because the caller is indicating that certain colors must be in the
		palette, but the user who created the Ditherer does not want those colors.
		"""
		return go.color_Palette(handle=_dither_go.dither_Ditherer_Quantize(self.handle, p.handle, m.handle))

# Python type for struct dither.OrderedDitherMatrix
class OrderedDitherMatrix(go.GoClass):
	"""OrderedDitherMatrix is used to hold a matrix used for ordered dithering. This\nis useful if you find a matrix somewhere and would like to try it out. You can\ncreate this struct and then give it to PixelMapperFromMatrix.\n\nThe matrix must be rectangular - each slice inside the first one must be the same\nlength.\n\nMax is the value all the matrix values will be divided by. Usually this is the\nproduct of the dimensions of the matrix (x*y), or the greatest value in the matrix\nplus one. For diagonal matrices or other matrices with repeated values, it is the\nlatter.\n\nLeaving Max as 0 will cause a panic.\n\nMatrix values should almost always range from 0 to Max-1. If the matrix you found\nranges from 1 to Max, just subtract 1 from every value when programming it.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dither_go.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dither_go.IncRef(self.handle)
		else:
			self.handle = _dither_go.dither_OrderedDitherMatrix_CTor()
			_dither_go.IncRef(self.handle)
			if  0 < len(args):
				self.Matrix = args[0]
			if "Matrix" in kwargs:
				self.Matrix = kwargs["Matrix"]
			if  1 < len(args):
				self.Max = args[1]
			if "Max" in kwargs:
				self.Max = kwargs["Max"]
	def __del__(self):
		_dither_go.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'dither.OrderedDitherMatrix{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'dither.OrderedDitherMatrix ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Matrix(self):
		return Slice_Slice_uint(handle=_dither_go.dither_OrderedDitherMatrix_Matrix_Get(self.handle))
	@Matrix.setter
	def Matrix(self, value):
		if isinstance(value, go.GoClass):
			_dither_go.dither_OrderedDitherMatrix_Matrix_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Max(self):
		return _dither_go.dither_OrderedDitherMatrix_Max_Get(self.handle)
	@Max.setter
	def Max(self, value):
		if isinstance(value, go.GoClass):
			_dither_go.dither_OrderedDitherMatrix_Max_Set(self.handle, value.handle)
		else:
			_dither_go.dither_OrderedDitherMatrix_Max_Set(self.handle, value)


# ---- Slices ---

# Python type for slice dither.ErrorDiffusionMatrix
class ErrorDiffusionMatrix(go.GoClass):
	"""ErrorDiffusionMatrix holds the matrix for the error-diffusion type of dithering.\nAn example of this would be Floyd-Steinberg or Atkinson.\n\nZero values can be used to represent pixels that have already been processed.\nThe current pixel is assumed to be the right-most zero value in the top row.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dither_go.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dither_go.IncRef(self.handle)
		else:
			self.handle = _dither_go.dither_ErrorDiffusionMatrix_CTor()
			_dither_go.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('dither_ErrorDiffusionMatrix.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dither_go.DecRef(self.handle)
	def __str__(self):
		s = 'dither.dither_ErrorDiffusionMatrix len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dither.dither_ErrorDiffusionMatrix([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dither_go.dither_ErrorDiffusionMatrix_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dither_go.dither_ErrorDiffusionMatrix_len(self.handle)
				return ErrorDiffusionMatrix(handle=_dither_go.dither_ErrorDiffusionMatrix_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Slice_float32(handle=_dither_go.dither_ErrorDiffusionMatrix_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dither_go.dither_ErrorDiffusionMatrix_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('dither_ErrorDiffusionMatrix.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _dither_go.dither_ErrorDiffusionMatrix_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dither_go.dither_ErrorDiffusionMatrix_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]
	def CurrentPixel(self):
		"""CurrentPixel() int
		
		CurrentPixel returns the index the current pixel.
		The current pixel is assumed to be the right-most zero value in the top row.
		In all matrixes that I have seen, the current pixel is always in the middle,
		but this function exists just in case.
		
		Therefore with an ErrorDiffusionMatrix named edm, the current pixel is at:
		    edm[0][edm.CurrentPixel()]
		
		Usually you'll want to cache this value.
		"""
		return _dither_go.dither_ErrorDiffusionMatrix_CurrentPixel(self.handle)


# ---- Maps ---


# ---- Constructors ---
def NewDitherer(palette):
	"""NewDitherer([]object palette) object
	
	NewDitherer creates a new Ditherer that uses a copy of the provided palette.
	If the palette is empty or nil then nil will be returned.
	All palette colors should be opaque.
	"""
	return Ditherer(handle=_dither_go.dither_NewDitherer(palette.handle))


# ---- Functions ---
def ErrorDiffusionStrength(edm, strength):
	"""ErrorDiffusionStrength([][]float edm, float strength) [][]float
	
	ErrorDiffusionStrength modifies an existing error diffusion matrix so that it will
	be applied with the specified strength.
	
	strength is usually a value from 0 to 1.0, where 1.0 means 100% strength, and will
	not modify the matrix at all. It is inversely proportional to contrast - reducing the
	strength increases the contrast. It can be useful at values like 0.8 for reducing
	noise in the dithered image.
	
	See the documentation for Bayer for more details.
	"""
	return ErrorDiffusionMatrix(handle=_dither_go.dither_ErrorDiffusionStrength(edm.handle, strength))
def RoundClamp(i):
	"""RoundClamp(float i) int
	
	RoundClamp clamps the number and rounds it, rounding ties to the nearest even number.
	This should be used if you're writing your own PixelMapper.
	"""
	return _dither_go.dither_RoundClamp(i)


