/*
cgo stubs for package dither_go.
File is generated by gopy. Do not edit.
gopy build -no-make -output=dither_go/bindings -vm=python3 ./dither_go github.com/tfuxu/dither-gopy
*/

package main

/*

#cgo CFLAGS: -I/usr/include/python3.11 -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: -L/usr/lib -lpython3.11 -ldl -lm

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"image"
	"image/color"
	"image/draw"

	"github.com/tfuxu/dither-go/dither_go"
	dither "github.com/tfuxu/dither-gopy"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: dither_go below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *image.Paletted
func ptrFromHandle_Ptr_image_Paletted(h CGoHandle) *image.Paletted {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*image.Paletted")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(image.Paletted{})).(*image.Paletted)
}
func handleFromPtr_Ptr_image_Paletted(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*image.Paletted", p))
}

// Converters for pointer handles for type: *image.RGBA
func ptrFromHandle_Ptr_image_RGBA(h CGoHandle) *image.RGBA {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*image.RGBA")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(image.RGBA{})).(*image.RGBA)
}
func handleFromPtr_Ptr_image_RGBA(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*image.RGBA", p))
}

// Converters for pointer handles for type: image.Image
func ptrFromHandle_image_Image(h CGoHandle) image.Image {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "image.Image")
	if p == nil {
		return nil
	}
	return p.(image.Image)
}
func handleFromPtr_image_Image(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("image.Image", p))
}

// Converters for non-pointer handles for type: image.Paletted
func ptrFromHandle_image_Paletted(h CGoHandle) *image.Paletted {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "image.Paletted")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(image.Paletted{})).(*image.Paletted)
}
func handleFromPtr_image_Paletted(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("image.Paletted", p))
}

// Converters for non-pointer handles for type: image.Point
func ptrFromHandle_image_Point(h CGoHandle) *image.Point {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "image.Point")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(image.Point{})).(*image.Point)
}
func handleFromPtr_image_Point(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("image.Point", p))
}

// Converters for non-pointer handles for type: image.RGBA
func ptrFromHandle_image_RGBA(h CGoHandle) *image.RGBA {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "image.RGBA")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(image.RGBA{})).(*image.RGBA)
}
func handleFromPtr_image_RGBA(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("image.RGBA", p))
}

// Converters for non-pointer handles for type: image.Rectangle
func ptrFromHandle_image_Rectangle(h CGoHandle) *image.Rectangle {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "image.Rectangle")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(image.Rectangle{})).(*image.Rectangle)
}
func handleFromPtr_image_Rectangle(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("image.Rectangle", p))
}

// Converters for pointer handles for type: color.Color
func ptrFromHandle_color_Color(h CGoHandle) color.Color {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "color.Color")
	if p == nil {
		return nil
	}
	return p.(color.Color)
}
func handleFromPtr_color_Color(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("color.Color", p))
}

// Converters for pointer handles for type: color.Model
func ptrFromHandle_color_Model(h CGoHandle) color.Model {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "color.Model")
	if p == nil {
		return nil
	}
	return p.(color.Model)
}
func handleFromPtr_color_Model(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("color.Model", p))
}

// Converters for implicit pointer handles for type: color.Palette
func ptrFromHandle_color_Palette(h CGoHandle) *color.Palette {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "color.Palette")
	if p == nil {
		return nil
	}
	return p.(*color.Palette)
}
func deptrFromHandle_color_Palette(h CGoHandle) color.Palette {
	p := ptrFromHandle_color_Palette(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_color_Palette(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("color.Palette", p))
}

// --- wrapping slice: color.Palette ---
//
//export color_Palette_CTor
func color_Palette_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_color_Palette(&color.Palette{}))
}

//export color_Palette_len
func color_Palette_len(handle CGoHandle) int {
	return len(deptrFromHandle_color_Palette(handle))
}

//export color_Palette_elem
func color_Palette_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_color_Palette(handle)
	return handleFromPtr_color_Color(s[_idx])
}

//export color_Palette_subslice
func color_Palette_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_color_Palette(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_color_Palette(&ss))
}

//export color_Palette_set
func color_Palette_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_color_Palette(handle)
	s[_idx] = ptrFromHandle_color_Color(_vl)
}

//export color_Palette_append
func color_Palette_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_color_Palette(handle)
	*s = append(*s, ptrFromHandle_color_Color(_vl))
}

// Converters for non-pointer handles for type: color.RGBA
func ptrFromHandle_color_RGBA(h CGoHandle) *color.RGBA {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "color.RGBA")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(color.RGBA{})).(*color.RGBA)
}
func handleFromPtr_color_RGBA(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("color.RGBA", p))
}

// Converters for non-pointer handles for type: color.RGBA64
func ptrFromHandle_color_RGBA64(h CGoHandle) *color.RGBA64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "color.RGBA64")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(color.RGBA64{})).(*color.RGBA64)
}
func handleFromPtr_color_RGBA64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("color.RGBA64", p))
}

// Converters for pointer handles for type: draw.Image
func ptrFromHandle_draw_Image(h CGoHandle) draw.Image {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "draw.Image")
	if p == nil {
		return nil
	}
	return p.(draw.Image)
}
func handleFromPtr_draw_Image(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("draw.Image", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: dither_go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []color.Color
func ptrFromHandle_Slice_color_Color(h CGoHandle) *[]color.Color {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]color.Color")
	if p == nil {
		return nil
	}
	return p.(*[]color.Color)
}
func deptrFromHandle_Slice_color_Color(h CGoHandle) []color.Color {
	p := ptrFromHandle_Slice_color_Color(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_color_Color(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]color.Color", p))
}

// --- wrapping slice: []color.Color ---
//
//export Slice_color_Color_CTor
func Slice_color_Color_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_color_Color(&[]color.Color{}))
}

//export Slice_color_Color_len
func Slice_color_Color_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_color_Color(handle))
}

//export Slice_color_Color_elem
func Slice_color_Color_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_color_Color(handle)
	return handleFromPtr_color_Color(s[_idx])
}

//export Slice_color_Color_subslice
func Slice_color_Color_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_color_Color(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_color_Color(&ss))
}

//export Slice_color_Color_set
func Slice_color_Color_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_color_Color(handle)
	s[_idx] = ptrFromHandle_color_Color(_vl)
}

//export Slice_color_Color_append
func Slice_color_Color_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_color_Color(handle)
	*s = append(*s, ptrFromHandle_color_Color(_vl))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export dither_go_SaveImage
func dither_go_SaveImage(img_data CGoHandle, output_path *C.char, encode_format *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = dither_go.SaveImage(ptrFromHandle_image_Image(img_data), C.GoString(output_path), C.GoString(encode_format))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export dither_go_CreatePalette
func dither_go_CreatePalette(colors CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := dither_go.CreatePalette(deptrFromHandle_Slice_color_Color(colors)...)

	return handleFromPtr_Slice_color_Color(&cret)
}

//export dither_go_CreateRGBA
func dither_go_CreateRGBA(r C.uchar, g C.uchar, b C.uchar, a C.uchar) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := dither_go.CreateRGBA(uint8(r), uint8(g), uint8(b), uint8(a))

	return handleFromPtr_color_RGBA(&cret)
}

//export dither_go_OpenImage
func dither_go_OpenImage(path *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := dither_go.OpenImage(C.GoString(path))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_image_Image(nil)
	}
	return handleFromPtr_image_Image(cret)
}

// ---- Package: dither ---

// ---- Types ---

// Converters for pointer handles for type: *dither.Ditherer
func ptrFromHandle_Ptr_dither_Ditherer(h CGoHandle) *dither.Ditherer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*dither.Ditherer")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer)
}
func handleFromPtr_Ptr_dither_Ditherer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*dither.Ditherer", p))
}

// Converters for pointer handles for type: *dither.OrderedDitherMatrix
func ptrFromHandle_Ptr_dither_OrderedDitherMatrix(h CGoHandle) *dither.OrderedDitherMatrix {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*dither.OrderedDitherMatrix")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(dither.OrderedDitherMatrix{})).(*dither.OrderedDitherMatrix)
}
func handleFromPtr_Ptr_dither_OrderedDitherMatrix(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*dither.OrderedDitherMatrix", p))
}

// Converters for implicit pointer handles for type: [][]uint
func ptrFromHandle_Slice_Slice_uint(h CGoHandle) *[][]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]uint")
	if p == nil {
		return nil
	}
	return p.(*[][]uint)
}
func deptrFromHandle_Slice_Slice_uint(h CGoHandle) [][]uint {
	p := ptrFromHandle_Slice_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]uint", p))
}

// --- wrapping slice: [][]uint ---
//
//export Slice_Slice_uint_CTor
func Slice_Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_uint(&[][]uint{}))
}

//export Slice_Slice_uint_len
func Slice_Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_uint(handle))
}

//export Slice_Slice_uint_elem
func Slice_Slice_uint_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_uint(handle)
	return handleFromPtr_Slice_uint(s[_idx])
}

//export Slice_Slice_uint_subslice
func Slice_Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_uint(&ss))
}

//export Slice_Slice_uint_set
func Slice_Slice_uint_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_uint(handle)
	s[_idx] = deptrFromHandle_Slice_uint(_vl)
}

//export Slice_Slice_uint_append
func Slice_Slice_uint_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_uint(handle)
	*s = append(*s, deptrFromHandle_Slice_uint(_vl))
}

// Converters for non-pointer handles for type: dither.Ditherer
func ptrFromHandle_dither_Ditherer(h CGoHandle) *dither.Ditherer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "dither.Ditherer")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer)
}
func handleFromPtr_dither_Ditherer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("dither.Ditherer", p))
}

// Converters for implicit pointer handles for type: dither.ErrorDiffusionMatrix
func ptrFromHandle_dither_ErrorDiffusionMatrix(h CGoHandle) *dither.ErrorDiffusionMatrix {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "dither.ErrorDiffusionMatrix")
	if p == nil {
		return nil
	}
	return p.(*dither.ErrorDiffusionMatrix)
}
func deptrFromHandle_dither_ErrorDiffusionMatrix(h CGoHandle) dither.ErrorDiffusionMatrix {
	p := ptrFromHandle_dither_ErrorDiffusionMatrix(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_dither_ErrorDiffusionMatrix(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("dither.ErrorDiffusionMatrix", p))
}

// Converters for non-pointer handles for type: dither.OrderedDitherMatrix
func ptrFromHandle_dither_OrderedDitherMatrix(h CGoHandle) *dither.OrderedDitherMatrix {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "dither.OrderedDitherMatrix")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(dither.OrderedDitherMatrix{})).(*dither.OrderedDitherMatrix)
}
func handleFromPtr_dither_OrderedDitherMatrix(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("dither.OrderedDitherMatrix", p))
}

// ---- Global Variables: can only use functions to access ---
//
//export dither_Atkinson
func dither_Atkinson() CGoHandle {
	return handleFromPtr_dither_ErrorDiffusionMatrix(&dither.Atkinson)
}

//export dither_Set_Atkinson
func dither_Set_Atkinson(val CGoHandle) {
	dither.Atkinson = deptrFromHandle_dither_ErrorDiffusionMatrix(val)
}

//export dither_Burkes
func dither_Burkes() CGoHandle {
	return handleFromPtr_dither_ErrorDiffusionMatrix(&dither.Burkes)
}

//export dither_Set_Burkes
func dither_Set_Burkes(val CGoHandle) {
	dither.Burkes = deptrFromHandle_dither_ErrorDiffusionMatrix(val)
}

//export dither_ClusteredDot4x4
func dither_ClusteredDot4x4() CGoHandle {
	return handleFromPtr_dither_OrderedDitherMatrix(&dither.ClusteredDot4x4)
}

//export dither_Set_ClusteredDot4x4
func dither_Set_ClusteredDot4x4(val CGoHandle) {
	dither.ClusteredDot4x4 = *ptrFromHandle_dither_OrderedDitherMatrix(val)
}

//export dither_ClusteredDot6x6
func dither_ClusteredDot6x6() CGoHandle {
	return handleFromPtr_dither_OrderedDitherMatrix(&dither.ClusteredDot6x6)
}

//export dither_Set_ClusteredDot6x6
func dither_Set_ClusteredDot6x6(val CGoHandle) {
	dither.ClusteredDot6x6 = *ptrFromHandle_dither_OrderedDitherMatrix(val)
}

//export dither_ClusteredDot6x6_2
func dither_ClusteredDot6x6_2() CGoHandle {
	return handleFromPtr_dither_OrderedDitherMatrix(&dither.ClusteredDot6x6_2)
}

//export dither_Set_ClusteredDot6x6_2
func dither_Set_ClusteredDot6x6_2(val CGoHandle) {
	dither.ClusteredDot6x6_2 = *ptrFromHandle_dither_OrderedDitherMatrix(val)
}

//export dither_ClusteredDot6x6_3
func dither_ClusteredDot6x6_3() CGoHandle {
	return handleFromPtr_dither_OrderedDitherMatrix(&dither.ClusteredDot6x6_3)
}

//export dither_Set_ClusteredDot6x6_3
func dither_Set_ClusteredDot6x6_3(val CGoHandle) {
	dither.ClusteredDot6x6_3 = *ptrFromHandle_dither_OrderedDitherMatrix(val)
}

//export dither_ClusteredDot8x8
func dither_ClusteredDot8x8() CGoHandle {
	return handleFromPtr_dither_OrderedDitherMatrix(&dither.ClusteredDot8x8)
}

//export dither_Set_ClusteredDot8x8
func dither_Set_ClusteredDot8x8(val CGoHandle) {
	dither.ClusteredDot8x8 = *ptrFromHandle_dither_OrderedDitherMatrix(val)
}

//export dither_ClusteredDotDiagonal16x16
func dither_ClusteredDotDiagonal16x16() CGoHandle {
	return handleFromPtr_dither_OrderedDitherMatrix(&dither.ClusteredDotDiagonal16x16)
}

//export dither_Set_ClusteredDotDiagonal16x16
func dither_Set_ClusteredDotDiagonal16x16(val CGoHandle) {
	dither.ClusteredDotDiagonal16x16 = *ptrFromHandle_dither_OrderedDitherMatrix(val)
}

//export dither_ClusteredDotDiagonal6x6
func dither_ClusteredDotDiagonal6x6() CGoHandle {
	return handleFromPtr_dither_OrderedDitherMatrix(&dither.ClusteredDotDiagonal6x6)
}

//export dither_Set_ClusteredDotDiagonal6x6
func dither_Set_ClusteredDotDiagonal6x6(val CGoHandle) {
	dither.ClusteredDotDiagonal6x6 = *ptrFromHandle_dither_OrderedDitherMatrix(val)
}

//export dither_ClusteredDotDiagonal8x8
func dither_ClusteredDotDiagonal8x8() CGoHandle {
	return handleFromPtr_dither_OrderedDitherMatrix(&dither.ClusteredDotDiagonal8x8)
}

//export dither_Set_ClusteredDotDiagonal8x8
func dither_Set_ClusteredDotDiagonal8x8(val CGoHandle) {
	dither.ClusteredDotDiagonal8x8 = *ptrFromHandle_dither_OrderedDitherMatrix(val)
}

//export dither_ClusteredDotDiagonal8x8_2
func dither_ClusteredDotDiagonal8x8_2() CGoHandle {
	return handleFromPtr_dither_OrderedDitherMatrix(&dither.ClusteredDotDiagonal8x8_2)
}

//export dither_Set_ClusteredDotDiagonal8x8_2
func dither_Set_ClusteredDotDiagonal8x8_2(val CGoHandle) {
	dither.ClusteredDotDiagonal8x8_2 = *ptrFromHandle_dither_OrderedDitherMatrix(val)
}

//export dither_ClusteredDotDiagonal8x8_3
func dither_ClusteredDotDiagonal8x8_3() CGoHandle {
	return handleFromPtr_dither_OrderedDitherMatrix(&dither.ClusteredDotDiagonal8x8_3)
}

//export dither_Set_ClusteredDotDiagonal8x8_3
func dither_Set_ClusteredDotDiagonal8x8_3(val CGoHandle) {
	dither.ClusteredDotDiagonal8x8_3 = *ptrFromHandle_dither_OrderedDitherMatrix(val)
}

//export dither_ClusteredDotHorizontalLine
func dither_ClusteredDotHorizontalLine() CGoHandle {
	return handleFromPtr_dither_OrderedDitherMatrix(&dither.ClusteredDotHorizontalLine)
}

//export dither_Set_ClusteredDotHorizontalLine
func dither_Set_ClusteredDotHorizontalLine(val CGoHandle) {
	dither.ClusteredDotHorizontalLine = *ptrFromHandle_dither_OrderedDitherMatrix(val)
}

//export dither_ClusteredDotSpiral5x5
func dither_ClusteredDotSpiral5x5() CGoHandle {
	return handleFromPtr_dither_OrderedDitherMatrix(&dither.ClusteredDotSpiral5x5)
}

//export dither_Set_ClusteredDotSpiral5x5
func dither_Set_ClusteredDotSpiral5x5(val CGoHandle) {
	dither.ClusteredDotSpiral5x5 = *ptrFromHandle_dither_OrderedDitherMatrix(val)
}

//export dither_ClusteredDotVerticalLine
func dither_ClusteredDotVerticalLine() CGoHandle {
	return handleFromPtr_dither_OrderedDitherMatrix(&dither.ClusteredDotVerticalLine)
}

//export dither_Set_ClusteredDotVerticalLine
func dither_Set_ClusteredDotVerticalLine(val CGoHandle) {
	dither.ClusteredDotVerticalLine = *ptrFromHandle_dither_OrderedDitherMatrix(val)
}

//export dither_FalseFloydSteinberg
func dither_FalseFloydSteinberg() CGoHandle {
	return handleFromPtr_dither_ErrorDiffusionMatrix(&dither.FalseFloydSteinberg)
}

//export dither_Set_FalseFloydSteinberg
func dither_Set_FalseFloydSteinberg(val CGoHandle) {
	dither.FalseFloydSteinberg = deptrFromHandle_dither_ErrorDiffusionMatrix(val)
}

//export dither_FloydSteinberg
func dither_FloydSteinberg() CGoHandle {
	return handleFromPtr_dither_ErrorDiffusionMatrix(&dither.FloydSteinberg)
}

//export dither_Set_FloydSteinberg
func dither_Set_FloydSteinberg(val CGoHandle) {
	dither.FloydSteinberg = deptrFromHandle_dither_ErrorDiffusionMatrix(val)
}

//export dither_Horizontal3x5
func dither_Horizontal3x5() CGoHandle {
	return handleFromPtr_dither_OrderedDitherMatrix(&dither.Horizontal3x5)
}

//export dither_Set_Horizontal3x5
func dither_Set_Horizontal3x5(val CGoHandle) {
	dither.Horizontal3x5 = *ptrFromHandle_dither_OrderedDitherMatrix(val)
}

//export dither_JarvisJudiceNinke
func dither_JarvisJudiceNinke() CGoHandle {
	return handleFromPtr_dither_ErrorDiffusionMatrix(&dither.JarvisJudiceNinke)
}

//export dither_Set_JarvisJudiceNinke
func dither_Set_JarvisJudiceNinke(val CGoHandle) {
	dither.JarvisJudiceNinke = deptrFromHandle_dither_ErrorDiffusionMatrix(val)
}

//export dither_Sierra
func dither_Sierra() CGoHandle {
	return handleFromPtr_dither_ErrorDiffusionMatrix(&dither.Sierra)
}

//export dither_Set_Sierra
func dither_Set_Sierra(val CGoHandle) {
	dither.Sierra = deptrFromHandle_dither_ErrorDiffusionMatrix(val)
}

//export dither_Sierra2
func dither_Sierra2() CGoHandle {
	return handleFromPtr_dither_ErrorDiffusionMatrix(&dither.Sierra2)
}

//export dither_Set_Sierra2
func dither_Set_Sierra2(val CGoHandle) {
	dither.Sierra2 = deptrFromHandle_dither_ErrorDiffusionMatrix(val)
}

//export dither_Sierra2_4A
func dither_Sierra2_4A() CGoHandle {
	return handleFromPtr_dither_ErrorDiffusionMatrix(&dither.Sierra2_4A)
}

//export dither_Set_Sierra2_4A
func dither_Set_Sierra2_4A(val CGoHandle) {
	dither.Sierra2_4A = deptrFromHandle_dither_ErrorDiffusionMatrix(val)
}

//export dither_Sierra3
func dither_Sierra3() CGoHandle {
	return handleFromPtr_dither_ErrorDiffusionMatrix(&dither.Sierra3)
}

//export dither_Set_Sierra3
func dither_Set_Sierra3(val CGoHandle) {
	dither.Sierra3 = deptrFromHandle_dither_ErrorDiffusionMatrix(val)
}

//export dither_SierraLite
func dither_SierraLite() CGoHandle {
	return handleFromPtr_dither_ErrorDiffusionMatrix(&dither.SierraLite)
}

//export dither_Set_SierraLite
func dither_Set_SierraLite(val CGoHandle) {
	dither.SierraLite = deptrFromHandle_dither_ErrorDiffusionMatrix(val)
}

//export dither_Simple2D
func dither_Simple2D() CGoHandle {
	return handleFromPtr_dither_ErrorDiffusionMatrix(&dither.Simple2D)
}

//export dither_Set_Simple2D
func dither_Set_Simple2D(val CGoHandle) {
	dither.Simple2D = deptrFromHandle_dither_ErrorDiffusionMatrix(val)
}

//export dither_StevenPigeon
func dither_StevenPigeon() CGoHandle {
	return handleFromPtr_dither_ErrorDiffusionMatrix(&dither.StevenPigeon)
}

//export dither_Set_StevenPigeon
func dither_Set_StevenPigeon(val CGoHandle) {
	dither.StevenPigeon = deptrFromHandle_dither_ErrorDiffusionMatrix(val)
}

//export dither_Stucki
func dither_Stucki() CGoHandle {
	return handleFromPtr_dither_ErrorDiffusionMatrix(&dither.Stucki)
}

//export dither_Set_Stucki
func dither_Set_Stucki(val CGoHandle) {
	dither.Stucki = deptrFromHandle_dither_ErrorDiffusionMatrix(val)
}

//export dither_TwoRowSierra
func dither_TwoRowSierra() CGoHandle {
	return handleFromPtr_dither_ErrorDiffusionMatrix(&dither.TwoRowSierra)
}

//export dither_Set_TwoRowSierra
func dither_Set_TwoRowSierra(val CGoHandle) {
	dither.TwoRowSierra = deptrFromHandle_dither_ErrorDiffusionMatrix(val)
}

//export dither_Vertical5x3
func dither_Vertical5x3() CGoHandle {
	return handleFromPtr_dither_OrderedDitherMatrix(&dither.Vertical5x3)
}

//export dither_Set_Vertical5x3
func dither_Set_Vertical5x3(val CGoHandle) {
	dither.Vertical5x3 = *ptrFromHandle_dither_OrderedDitherMatrix(val)
}

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: dither.Ditherer ---
//
//export dither_Ditherer_CTor
func dither_Ditherer_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_dither_Ditherer(&dither.Ditherer{}))
}

//export dither_Ditherer_Matrix_Get
func dither_Ditherer_Matrix_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_dither_Ditherer(handle)
	return handleFromPtr_dither_ErrorDiffusionMatrix(&op.Matrix)
}

//export dither_Ditherer_Matrix_Set
func dither_Ditherer_Matrix_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_dither_Ditherer(handle)
	op.Matrix = deptrFromHandle_dither_ErrorDiffusionMatrix(val)
}

//export dither_Ditherer_Special_Get
func dither_Ditherer_Special_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_dither_Ditherer(handle)
	return C.longlong(int(op.Special))
}

//export dither_Ditherer_Special_Set
func dither_Ditherer_Special_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_dither_Ditherer(handle)
	op.Special = dither.SpecialDither(int(val))
}

//export dither_Ditherer_SingleThreaded_Get
func dither_Ditherer_SingleThreaded_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_dither_Ditherer(handle)
	return boolGoToPy(op.SingleThreaded)
}

//export dither_Ditherer_SingleThreaded_Set
func dither_Ditherer_SingleThreaded_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_dither_Ditherer(handle)
	op.SingleThreaded = boolPyToGo(val)
}

//export dither_Ditherer_Serpentine_Get
func dither_Ditherer_Serpentine_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_dither_Ditherer(handle)
	return boolGoToPy(op.Serpentine)
}

//export dither_Ditherer_Serpentine_Set
func dither_Ditherer_Serpentine_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_dither_Ditherer(handle)
	op.Serpentine = boolPyToGo(val)
}

//export dither_Ditherer_SetBayer
func dither_Ditherer_SetBayer(_handle CGoHandle, x C.ulonglong, y C.ulonglong, strength C.float, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*dither.Ditherer")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).SetBayer(uint(x), uint(y), float32(strength))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).SetBayer(uint(x), uint(y), float32(strength))
	}
}

//export dither_Ditherer_SetOrdered
func dither_Ditherer_SetOrdered(_handle CGoHandle, odm CGoHandle, strength C.float, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*dither.Ditherer")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).SetOrdered(*ptrFromHandle_dither_OrderedDitherMatrix(odm), float32(strength))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).SetOrdered(*ptrFromHandle_dither_OrderedDitherMatrix(odm), float32(strength))
	}
}

//export dither_Ditherer_SetRandomGrayscale
func dither_Ditherer_SetRandomGrayscale(_handle CGoHandle, min C.float, max C.float, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*dither.Ditherer")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).SetRandomGrayscale(float32(min), float32(max))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).SetRandomGrayscale(float32(min), float32(max))
	}
}

//export dither_Ditherer_SetRandomRGB
func dither_Ditherer_SetRandomRGB(_handle CGoHandle, minR C.float, maxR C.float, minG C.float, maxG C.float, minB C.float, maxB C.float, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*dither.Ditherer")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).SetRandomRGB(float32(minR), float32(maxR), float32(minG), float32(maxG), float32(minB), float32(maxB))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).SetRandomRGB(float32(minR), float32(maxR), float32(minG), float32(maxG), float32(minB), float32(maxB))
	}
}

//export dither_Ditherer_ClearMapper
func dither_Ditherer_ClearMapper(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*dither.Ditherer")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).ClearMapper()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).ClearMapper()
	}
}

//export dither_Ditherer_GetPalette
func dither_Ditherer_GetPalette(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*dither.Ditherer")
	if __err != nil {
		return handleFromPtr_Slice_color_Color(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).GetPalette()

	return handleFromPtr_Slice_color_Color(&cret)
}

//export dither_Ditherer_Dither
func dither_Ditherer_Dither(_handle CGoHandle, src CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*dither.Ditherer")
	if __err != nil {
		return handleFromPtr_image_Image(nil)
	}
	return handleFromPtr_image_Image(gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).Dither(ptrFromHandle_image_Image(src)))

}

//export dither_Ditherer_GetColorModel
func dither_Ditherer_GetColorModel(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*dither.Ditherer")
	if __err != nil {
		return handleFromPtr_color_Model(nil)
	}
	return handleFromPtr_color_Model(gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).GetColorModel())

}

//export dither_Ditherer_DitherCopy
func dither_Ditherer_DitherCopy(_handle CGoHandle, src CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*dither.Ditherer")
	if __err != nil {
		return handleFromPtr_Ptr_image_RGBA(nil)
	}
	return handleFromPtr_Ptr_image_RGBA(gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).DitherCopy(ptrFromHandle_image_Image(src)))

}

//export dither_Ditherer_DitherPaletted
func dither_Ditherer_DitherPaletted(_handle CGoHandle, src CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*dither.Ditherer")
	if __err != nil {
		return handleFromPtr_Ptr_image_Paletted(nil)
	}
	return handleFromPtr_Ptr_image_Paletted(gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).DitherPaletted(ptrFromHandle_image_Image(src)))

}

//export dither_Ditherer_Draw
func dither_Ditherer_Draw(_handle CGoHandle, dst CGoHandle, r CGoHandle, src CGoHandle, sp CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*dither.Ditherer")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).Draw(ptrFromHandle_draw_Image(dst), *ptrFromHandle_image_Rectangle(r), ptrFromHandle_image_Image(src), *ptrFromHandle_image_Point(sp))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).Draw(ptrFromHandle_draw_Image(dst), *ptrFromHandle_image_Rectangle(r), ptrFromHandle_image_Image(src), *ptrFromHandle_image_Point(sp))
	}
}

//export dither_Ditherer_Quantize
func dither_Ditherer_Quantize(_handle CGoHandle, p CGoHandle, m CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*dither.Ditherer")
	if __err != nil {
		return handleFromPtr_color_Palette(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(dither.Ditherer{})).(*dither.Ditherer).Quantize(deptrFromHandle_color_Palette(p), ptrFromHandle_image_Image(m))

	return handleFromPtr_color_Palette(&cret)
}

// --- wrapping struct: dither.OrderedDitherMatrix ---
//
//export dither_OrderedDitherMatrix_CTor
func dither_OrderedDitherMatrix_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_dither_OrderedDitherMatrix(&dither.OrderedDitherMatrix{}))
}

//export dither_OrderedDitherMatrix_Matrix_Get
func dither_OrderedDitherMatrix_Matrix_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_dither_OrderedDitherMatrix(handle)
	return handleFromPtr_Slice_Slice_uint(&op.Matrix)
}

//export dither_OrderedDitherMatrix_Matrix_Set
func dither_OrderedDitherMatrix_Matrix_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_dither_OrderedDitherMatrix(handle)
	op.Matrix = deptrFromHandle_Slice_Slice_uint(val)
}

//export dither_OrderedDitherMatrix_Max_Get
func dither_OrderedDitherMatrix_Max_Get(handle CGoHandle) C.ulonglong {
	op := ptrFromHandle_dither_OrderedDitherMatrix(handle)
	return C.ulonglong(op.Max)
}

//export dither_OrderedDitherMatrix_Max_Set
func dither_OrderedDitherMatrix_Max_Set(handle CGoHandle, val C.ulonglong) {
	op := ptrFromHandle_dither_OrderedDitherMatrix(handle)
	op.Max = uint(val)
}

// ---- Slices ---

// --- wrapping slice: dither.ErrorDiffusionMatrix ---
//
//export dither_ErrorDiffusionMatrix_CTor
func dither_ErrorDiffusionMatrix_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_dither_ErrorDiffusionMatrix(&dither.ErrorDiffusionMatrix{}))
}

//export dither_ErrorDiffusionMatrix_len
func dither_ErrorDiffusionMatrix_len(handle CGoHandle) int {
	return len(deptrFromHandle_dither_ErrorDiffusionMatrix(handle))
}

//export dither_ErrorDiffusionMatrix_elem
func dither_ErrorDiffusionMatrix_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_dither_ErrorDiffusionMatrix(handle)
	return handleFromPtr_Slice_float32(s[_idx])
}

//export dither_ErrorDiffusionMatrix_subslice
func dither_ErrorDiffusionMatrix_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_dither_ErrorDiffusionMatrix(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_dither_ErrorDiffusionMatrix(&ss))
}

//export dither_ErrorDiffusionMatrix_set
func dither_ErrorDiffusionMatrix_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_dither_ErrorDiffusionMatrix(handle)
	s[_idx] = deptrFromHandle_Slice_float32(_vl)
}

//export dither_ErrorDiffusionMatrix_append
func dither_ErrorDiffusionMatrix_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_dither_ErrorDiffusionMatrix(handle)
	*s = append(*s, deptrFromHandle_Slice_float32(_vl))
}

//export dither_ErrorDiffusionMatrix_CurrentPixel
func dither_ErrorDiffusionMatrix_CurrentPixel(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*dither.ErrorDiffusionMatrix")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(vifc.(*dither.ErrorDiffusionMatrix).CurrentPixel())

}

// ---- Maps ---

// ---- Constructors ---

//export dither_NewDitherer
func dither_NewDitherer(palette CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_dither_Ditherer(dither.NewDitherer(deptrFromHandle_Slice_color_Color(palette)))

}

// ---- Functions ---

//export dither_ErrorDiffusionStrength
func dither_ErrorDiffusionStrength(edm CGoHandle, strength C.float) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := dither.ErrorDiffusionStrength(deptrFromHandle_dither_ErrorDiffusionMatrix(edm), float32(strength))

	return handleFromPtr_dither_ErrorDiffusionMatrix(&cret)
}

//export dither_RoundClamp
func dither_RoundClamp(i C.float) C.ushort {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.ushort(dither.RoundClamp(float32(i)))

}
